[{"title":"虚拟摇杆（Joystick）的实现原理.md","url":"/2019/12/10/虚拟摇杆（Joystick）的实现原理-md/","content":"\n# 虚拟摇杆（Joystick）的实现原理\n\n\n## 三个组成对象\n在移动端，用虚拟摇杆来控制物体的移动是一种体验非常棒的交互方式。这个笔记中，注重分享摇杆的实现原理，与语言和平台无关，后面会有一个用 JS 实现的在线演示 Demo。\n\n摇杆通常由三个部分组成：摇杆按钮、摇杆滑块、滑块运动范围。\n\n滑块运动范围决定了滑块最大偏移摇杆按钮的长度，也决定了**第一次触摸事件的响应范围**。\n\n如下图所示，左边是没有事件输入时的样子，通常虚线框的响应范围是透明的，大小根据业务交互来定，而滑块在没有事件输入时是不显示的。右边是触发 Touch 事件后，滑块显示在手指滑动的位置与方向。\n\n![图示1](https://tva1.sinaimg.cn/large/006tNbRwgy1g9skjcyrkwj318g0m8mym.jpg)\n\n## 输出值的计算方式\n从上图的右边可以看出，在摇杆的运动中，我们能得到两个值，一个是原点（第一次点击屏幕的坐标点，这里我们假设是摇杆按钮的中心点）与滑块中心点的距离。以这个距离为半径，摇杆按钮中心为圆心，画一个圆，能得到滑块在这个圆上的角度。\n\n这个距离值可以反映到要控制的物体的运动速度，角度可以反映到我们要控制的物体的运动方向。\n\n![图示2](https://tva1.sinaimg.cn/large/006tNbRwgy1g9skjfg87ij318g0m80u6.jpg)\n\n### 距离\n距离的求出比较简单，计算两个点的坐标之间的距离即可，此时滑块运动范围是这个距离的最大值，我们可以根据这个最大值与距离的比例来决定我们的运动速度。以 JS 为例：\n```javascript\nMath.sqrt(\n(y2 - y1) * (y2 - y1) +\n(x2 - x1) * (x2 - x1)\n)\n```\n\n### 角度\n根据三角函数可以得到 α 的角度，这个角度就是我们要输出的值，计算步骤：\n1. 求出 Delta Y，也就是绿色线条的长度，`deltaY = y2 - y1`\n2. 求出 Delta X，也就是黄色线条的长度，`deltaX = x2 - x1`\n3. 用反三角函数公式计算 α 的弧度 radian，以 JS 为例： `Math.atan(deltaY, deltaX)`\n4. 再转角度  `degree = radian * 180 / PI`\n\n这里得到的角度值是以 X 轴为零点，如果我们这里是以 12 点钟方向为零点，这里计算的角度还需要再加 90 度再模 360。具体可以根据业务的需要做修改。\n\n## 摇杆的交互实现\n### 摇杆按钮\n大部分的按钮，只是一个静态的 UI，告诉用户这里有一个虚拟摇杆，不需要在交互中做出修改。如果原点是动态的，那摇杆按钮需要移动到原点坐标。\n\n### 摇杆滑块\n#### 方向\n滑块的方向总是等于我们手指相对原点（摇杆按钮中心点）运动的方向。所以可以用上面获取的角度值来修改滑块的旋转角度。\n\n#### 回弹\n当抬起手指后，滑块需要回弹到摇杆按钮的中心点，这里的可以使用各个平台下的 tween 类库来实现缓动回弹。上面提到的角度旋转为了更好的感官体验，也可以使用 tween 类库来做。\n\n### 事件的响应\n虚拟摇杆的实现涉及到这三个事件，可能各个平台略有不同，下面简单的列出每个事件要处理的逻辑。\n\n#### TouchBegin\n1. 获取第一个手指点击的位置\n2. 记录坐标点，定为原点\n3. 显示滑块\n4. 把滑块的坐标设置成原点坐标\n5. 如果移动摇杆按钮，记录摇杆按钮当前位置为中心点，将摇杆按钮移动到原点\n\n#### TouchMove\n1. 获取新的手指位置\n2. 获取上一次手指位置\n3. 计算差值，得出新的滑块位置\n4. 计算新位置与原点的角度\n5. 计算新位置与原点的距离\n6. 设置滑块旋转角度\n7. 防止超出滑块的最大距离，修正新的滑块位置\n8. 将滑块移动到新的位置\n9. 保存当前手指位置\n\n#### TouchEnd\n1. 回弹滑块\n2. 滑块回弹结束后消失\n3. 如果移动滑块按钮，将摇杆按钮重置回中心点\n\n## DEMO 演示（JS 实现）\n<iframe src=\"https://joystick.stackblitz.io/\" width=\"700px\" height=\"500px\" frameborder=\"0\" scrolling=\"no\"> </iframe>\n\n[代码地址](https://stackblitz.com/edit/joystick)\n\n## 获取输入值之后\n根据具体业务，可以自行封装几个事件，用于值的输出。\n\n### 计算运动速度\n根据滑块离原点的距离与最大运动范围的比例，我们可以对速度进行线性的关联，也可以分段离散来实现速度状态机。\n\n### 计算运动方向\n根据速度，再结合方向角度，利用三角函数可以计算 x, y 的运动分量。用分量计算新的物体位置。\n\n## PS\n后续会使用 Rx.js 来实现这个组件，并对其进行封装。","tags":["笔记"]},{"title":"2019 Learning In Depth","url":"/2019/02/13/2019-Learning-In-Depth/","content":"\n这个计划在春节前就写好了，使用幕布写的，今天整理成一篇博文，挑一些简单的活来让自己坚持写博客。\n\n## 技术\n\n根据今年的工作安排，主要集中在数据可视化和强交互的仿真软件上。所以自己技术的关注点也是围绕在这两点上。\n\n### 数据可视化\n\n相关书籍：\n- [《数据可视化之美》](https://book.douban.com/subject/6439420/)\n- [《数据之美》](https://book.douban.com/subject/25833225/)\n- [《鲜活的数据》](https://book.douban.com/subject/19952397/)\n\n目标是完成 **与潮鞋相光的可视化页面**，可能在完成的过程中还要学习数据分析的入门知识。\n\n### 设计模式\n重新看设计模式是因为强交互的仿真软件，如果不能够很好的设计模块和解耦，复杂的业务场景会把代码弄得一团糟。另外去年又开始使用  TypeScript，所以今年打算重温一下设计模式并且输出一些 TypeScript 设计模式实践的内容。\n\n相关书籍：\n- [《JavaScript设计模式》](https://book.douban.com/subject/26589719/)\n\n目标是 **用 TypeScript 实现前端相关场景，输出为系列文章**。\n\n### 函数式\n去年我都是专注在 Vue 技术栈上，因为函数式、无转态组件及无缝支持 TypeScript，打算全面转到 React 上来。目前团队项目 React 和 Vue 一半一半。还有 Rx.js 也需要一些函数式编程知识的铺垫，所以上半年要完成这些计划。\n\n相关书籍：\n- [《Haskell 趣学指南》](https://book.douban.com/subject/25803388/)\n- [《JavaScript 函数式编程指南》](https://book.douban.com/subject/30354711/)\n- [《深入浅出 RxJS》](https://book.douban.com/subject/30217949/)\n\n目标 **用函数式的思维解决某些业务问题，全面拥抱 React**。\n\n### 其他关注点\n没有放入 WebAssembly了，去年年底学习了一下 Go 语言，写了一个 WebAssembly 版本的 TodoList，真正深入去学习的话，对于 Go 或者 C/C++ 的要求才是重点。感觉暂时可以不作为主战场，碰到性能瓶颈和有优秀的解决方案应用时再去研究。\n\n今年有一个要深入的就是 V8 的一些知识了，写 JS 写了这么久，是该对 JS Runtime 去坐一些了解了，但是 V8 的资料比较少，大概只能借助 V8 的团队 [Blog](https://v8.dev/) 去学习了（[中文版](https://v8.js.cn/)）。\n\nPWA 因为我们写的大多是中后台业务，如果有一些偏工具型无网络可用场景的 WebApp 能用得上，打算上半年自己写个 Demo 实践一波。\n\n得益于 K8S，我们运行 Web 的环境都是支持 HTTP2 的，在中后台业务里应该能用上不少 HTTP2 的新特性。\n\n- PWA\n- V8\n- HTTP2\n\n### 温故基础知识\n作为一个合格的程序员，基础知识不能丢。\n\n- 数据结构\n- LeetCode 100题\n- Linux\n\n## 生活\n### 记账\n只是记录自己的支出，从年底做了这个计划来，已经完完整整的记录了一个月了，用的 App 是 [鲨鱼记账](http://www.shayujizhang.com/)。\n\n### 健身\n- 一周两次超级猩猩\n- 自己练习上肢力量\n- 增重到 60KG 的体重\n- 达到 13% 体脂率\n\n### 摄影摄像\n- 一个月整理一次照片\n- 整理放入微云\n- 两周整理一个Vlog\n\n### 阅读\n基本原则：\n- 思维导图\n- 书评\n- 小说类至少输出 140 字的短评\n\n### 书单及公开课：\n- [《杀死一只知更鸟》](https://book.douban.com/subject/6781808/)\n- [《集装箱改变世界（修订版）》](https://book.douban.com/subject/25795595/)\n\n心理学：\n- [《直觉泵和其他思考工具》](https://book.douban.com/subject/30340107/)\n- [《幸福课》](http://open.163.com/special/positivepsychology/)\n- [《领袖心理学》](http://open.163.com/special/opencourse/psychologyofleadership.html)\n\n哲学：\n- [《人生的智慧》](https://book.douban.com/subject/25867570/)\n- [《公正》](http://open.163.com/special/justice/)\n\n学习方法 & 认知\n- [《刻意练习》](https://book.douban.com/subject/26895993/)\n- [《策略思维》](https://book.douban.com/subject/26990027/)\n","tags":["个人"]},{"title":"2018年终总结","url":"/2019/01/26/2018年终总结/","content":"\n## 写在开头\n今年在人生中算是一个蛮大的转变了，工作职能上部分的转变，生活中从丈夫到为人父，物质上达成了自己的一个小心愿。部门从高楼渐起，到宾客散去，一年发生了太多。\n\n今年没有给自己立 Flag，总体的目标就是更好的生活，更好的沉淀自己，包括基础技术、前端领域、做人、看人。\n\n## 工作\n从1人的前端，到4人的前端团队，多种技术栈的尝试：\n1. React + Typescript + Antd + Redux\n2. Vue + Vuex + Nuxt.js\n3. Vue + Typescript + Vuex\n4. Nodejs\n5. 小程序\n\n### 团队建设\n团队的氛围没有，战斗力也没有汇聚和提高。这不是我的初衷，只是当事情没有符合我预期的发展时，我选择了逃避，放任不管。今年初尝团队的管理，这个状况算是好，也算是坏。对比当初的雄心壮志，是很失败的一次经历。\n\n好的一面是能够遇到最差的人，知道如何去应对这种人，在面试的时候如何去 鉴别这类人。\n\n坏处就是现在这种团队的氛围不太是我想要的，和我之前一开始的设想是完全偏离的，我其实是不太允许团队中有这种的人存在的。这或许对他人是一件不太公平的事情。\n\n### Krishna\nKrishna 也从无到有，因为后端设计的相当 Fancy，我对自己的前端整体的设计也还算满意。虽然中间的细节还有很多值得优化的地方，如果这个产品能继续走下去，还是能好好去优化它的前端部分的。包括国际化、工程的组织、前端 UI 的测试测试驱动等。\n\n### 前端导师\n第一次接受这么个活，带 10 多个 2017 年毕业生，在培训的整体规划上没有做的太好，没有把\n\n> 前端工程师首先必须是一个程序员  \n\n这个理念给传输到，是我的失职。自己之前的思考也没有那么的系统。过程中我也没有太多的去强调一些自己的技术价值观，增强自己的影响力。\n\n现在反而很怕去输出价值观了，一方面不屑你的人，说出来也不会有人理你，一方面又怕自己的价值观是错误的，很难找到一个在前端方向有对等的价值观的交流。\n\n很多的前端程序员其实是不配做一个程序员，转而成为前端。或许当年的我也是这样。\n\n和几个 leader 的沟通确特别的对等，虽然可能价值观不一定完全相同，但是可以吸收，交换彼此的观念，也让我学习到了特别多他们身上有的一些特质，专注、认真、全面、系统。每一种技术，必然会弄清楚使用场景，实现的原理，这样做的好处。\n\n## 技术\n今年关注的新的技术，大多是为了了解特定的设计模式和不同语言的编程范式。让自己的代码更加优雅。\n\n### React\n因为对函数式编程的框架实现感兴趣，用了 React 做了一定的实践，不是特别熟悉，只能算是能用，了解。\n\n### 深入了解 Vue 实现\n看了几个章节的框架实现，并没有看完，也没有能够复述 Vue 整个设计思想的能力。还需要继续的学习。\n\n### Redux\n跟着一篇原理教程，实现了 Redux 的核心功能。\n* Reducer\n* ReducerCompose\n\n### GraphQL\nGraphQL 就是用一种特定的 QL 去动态查询后台实现的 query scheme，在 scheme 内动态的获取需要的数据。\n用 Node 写 GraphQL 是一件非常简单的事情，难的是设计出一个符合业务的数据图。\n\n### Go\nGo 语言里面的一些语法特点，如：\n\n* goroutine\n* channel\n* defer\n* mutex\n\n都是一些未接触过的概念，除语言的本身，更多的是去了解不同的并发机制，它们的优势以及它们的不足。\n\n### Python\nPython 本来是我学习的第一门语言，用它来写过 web，写过脚本及爬虫。但是工作后一直用 JS，已经完全忘了 Python 了。后端人力不足，就用 Python 写了个从 hive 取数，存入 Mysql 的脚本。也算是温习了一遍 Python 语法和工程化。\n\n### WebSocket\n通过项目及一些原理解释的文章，弄清楚了 Websocket 的一些基础概念，不在流于表面，只会使用 socket.io。\n\n### 工程化\n* 团队 Git Flow\n* 一定程度的 Code Review\n* CI/CD 的流程\n\n## 生活\n### Baby 快出生了\n不知道为人父后是什么样的体验，不过我会尽我的能力让他成为一个独立，有追求的人。\n\n### 换了车\n换掉了之前的 Focus，内饰味道 3 年了还没有散掉，又准备要小孩，为了不再受毒气侵害，咬咬牙换上了最心爱的 BMW。\n\n### 健身了\n健身的地点是 SuperMonkey，坚持三个月了，加上有我妈的照顾，体重增加了 5KG，脱掉衣服看上去也不是那么瘦不拉几了。\n\n### 作息\n因为每天早上要送老婆上班，起的很早，也很少熬夜了，希望自己的老毛病在下一次复检的时候能有一些好转。\n\n## 最后\n2018年工作没什么太大的起色，尝试了角色的转换，是失败的。技术上输出分享太少。2019年必须坚持一些好的习惯、固定一些工作生活的方式了。不能这样自由散漫了。","tags":["个人"]},{"title":"Vue.js SSR Step by Step (3) - 改造 vue/webpack 脚手架","url":"/2017/11/10/vue-ssr-3/","content":"\n通过前面两篇文章，写了一个简单的支持 vue 同构的 webpack 配置，但是还没有 dev server，不能热更新和实时编译，用于开发还是非常的麻烦。\n\nVue 官方的 webpack 脚手架只是针对客户端的，功能强大，配置齐全。所以在这个官方脚手架的基础上改了一个支持 #SSR# 的版本，在改的过程中参考了 [GitHub - vuejs/vue-hackernews-2.0: HackerNews clone built with Vue 2.0, vue-router & vuex, with server-side rendering](https://github.com/vuejs/vue-hackernews-2.0/tree/master/)。\n\n改过后的源码在 [Github](https://github.com/wheato/vue-ssr-boilerplate/tree/master) 上，使用方式：`vue init wheato/vue-ssr-boilerplate project-name`。接下来简单的说说这个修改的过程。\n\n## 修改代码\n这一部分主要是增加两个入口 ，修改内容和之前文章还有官方文档一样。如果有用到 vue-router 还要修改 route.js，具体修改可以看官方文档。有了 vue-router 我们就可以在组件里面定义静态方法，服务端调用注入数据。\n```\n// Foo.vue\n<template>\n  <div>\n    <h2>Foo</h2>\n  </div>\n</template>\n\n<script>\nexport default {\n  preFetch(data) {\n    console.log(data)\n  },\n  data () {\n    return {}\n  }\n}\n</script>\n```\n\n```\n// entry-server.js\nimport { createApp } from './app.js'\nexport default context => {\n  return new Promise((resolve, reject) => {\n    const { app, router } = createApp()\n    router.push('/foo')\n    router.onReady(() => {\n      const matchedComponents = router.getMatchedComponents()\n      matchedComponents.forEach(p => {\n        p.preFetch('数据')\n      })\n      resolve(app)\n    }, reject)\n  })\n}\n```\n\n## 增加 server.js\nserver.js 基本上就是从 vue-hackernews-2.0 种复制过来的，做了一些删减，使用 express，也可以使用 Koa。\n\n## 修改 webpack.*.conf.js\nwebpack.prod.conf.js 的修改点：\n* webpack.prod.conf.js 改成 webpack.server.conf.js；\n* 去掉 html-webpack-plugin，用了 SSR，不需要在把资源自动注入 html 文件中了；\n* 把压缩 css 和 js 插件放到条件判断中，只有生产环境才压缩文件；\n* 修改入口；\n* 增加 `process.env.VUE_ENV = ‘client’`；\n* 增加 vue-server-renderer client 端插件。\n\n增加 webpack.server.conf.js：\n* 在 client 基础上去掉 CommonsChunkPlugin；\n* 修改入口文件，和输出文件，编译目标平台；\n* 增加 vue-server-renderer server 端插件；\n* 增加 extract-text-webpack-plugin，不把 css 编译进 server 端中；\n* 增加 `process.env.VUE_ENV = ‘server’`。\n\nwebpack.dev.conf.js 中增加 vue-server-renderer client 端插件，修改入口为 entry-client.js。\n\n## 修改 dev-server.js\ndev-server.js 这部分修改挺大的， 其中 client 的配置使用 webpack.dev.conf.js。\n\nClient 部分没有太多的改动，必须要使用的两个插件 webpack-dev-middleware 和 webpack-hot-middleware。增加了 clientCompiler done 事件的回调，把编译好的 client-bundle 文件保存进 clientManifest 中，页面刷新的时候服务器渲染就能同步到之前修改过的内容。\n```\n// dev middleware\nvar clientCompiler = webpack(clientWebpackConfig)\nvar devMiddleware = require('webpack-dev-middleware')(clientCompiler, {\n  publicPath: clientWebpackConfig.output.publicPath,\n  noInfo: true\n})\napp.use(devMiddleware)\nclientCompiler.plugin('done', stats => {\n  stats = stats.toJson()\n  stats.errors.forEach(err => console.error(err))\n  stats.warnings.forEach(err => console.warn(err))\n  if (stats.errors.length) return\n  clientManifest = JSON.parse(readFile(\n    devMiddleware.fileSystem,\n    'vue-ssr-client-manifest.json'\n  ))\n  update()\n})\n// hot middleware\nvar hotMiddleware = require('webpack-hot-middleware')(clientCompiler, { heartbeat: 5000 })\napp.use(hotMiddleware)\n```\n\nServer 部分中，devMiddleware 的代码更新不到服务端，所以要添加 watch 事件，实时编译 server-bundle。\n```\n// watch and update server renderer\nvar serverCompiler = webpack(serverWebpackConfig)\nvar mfs = new MFS()\nserverCompiler.outputFileSystem = mfs\nserverCompiler.watch({}, (err, stats) => {\n  if (err) throw err\n  stats = stats.toJson()\n  if (stats.errors.length) return\n  // read bundle generated by vue-ssr-webpack-plugin\n  bundle = JSON.parse(readFile(mfs, 'vue-ssr-server-bundle.json'))\n  update()\n})\n// read template from disk and watch\ntemplate = fs.readFileSync(templatePath, 'utf-8')\nchokidar.watch(templatePath).on('change', () => {\n  template = fs.readFileSync(templatePath, 'utf-8')\n  console.log('index.html template updated.')\n  hotMiddleware.publish({ action: 'reload' })\n})\n```\n\n\n## 修改 build.js\n修改点比较简单，在 client 端编译完后，再增加编译 server 端就可以。最后修改一下 package.json 的命令。\n```\nnpm run dev\nnpm run build\nnpm run server // 启动服务器\n```\n\n更多的代码可以使用脚手架模板创建一个空项目跑一下看看。\n\n## Vue.js SSR Step by Step 系列\n* [Vue.js SSR Step by Step (1) - 实现简单的client-only vue-webpack 配置](https://juejin.im/post/6844903507556843534)\n* [Vue.js SSR Step by Step (2) - 一个简单的同构DEMO](https://juejin.im/post/6844903509050015758)","tags":["Vue"]},{"title":"Vue.js SSR Step by Step (2) - 一个简单的同构DEMO","url":"/2017/11/08/vue-ssr-2/","content":"\n上一篇文章中介绍了如何从零开始搭建一个简单的 client-only webpack 配置。\n接下来我们在前面代码的基础上写一个简单的前后端同构的DEMO。\n\n## 改写入口\n> 当编写纯客户端(client-only)代码时，我们习惯于每次在新的上下文中对代码进行取值。但是，Node.js 服务器是一个长期运行的进程。当我们的代码进入该进程时，它将进行一次取值并留存在内存中。这意味着如果创建一个单例对象，它将在每个传入的请求之间共享。  \n>   \n为了避免状态单例，改写入口， [Vue SSR 官方文档](https://ssr.vuejs.org/zh/structure.html)介绍的比较详细了，一定要去看一看。\n创建对应的文件后，src 目录是这样的：\n```\n.\n├── App.vue\n├── app.js\n├── assets\n│   └── logo.png\n├── entry-client.js\n└── entry-server.js\n```\n\n改写 app.js 把里面创建 Vue 实例的部分改写一个工厂函数，用于创建返回 Vue 实例。\n```javascript\n// app.js\nimport Vue from 'vue'\nimport App from './App.vue'\n\nexport function createApp () {\n  const app = new Vue({\n    render: h => h(App)\n  })\n  return app\n}\n```\n\n```javascript\n// entry-client.js\nimport { createApp } from './app.js'\n\nconst app = createApp()\napp.$mount('#app')\n```\n\n```javascript\n// entry-server.js\nimport { createApp } from './app.js'\n\nexport default context => {\n  const app = createApp()\n  return app\n}\n```\n\n## 改写 webpack 配置\n因为服务器渲染的配置和客户端的配置略有不同，但其中有很多共用的配置，官方建议我们使用三个不同的配置文件：base、client、server， 通过 **webpack-merge** 插件来实现对 base 配置文件的覆盖和扩展。\n```\nbuild 目录下的文件目录\n.\n├── webpack.base.conf.js\n├── webpack.client.conf.js\n└── webpack.server.conf.js\n```\n\n再把之前 webpack.config.js 中的内容复制到 webpack.base.conf.js 中。在 webpack.server.conf.js 中加入 SSR 的 client 插件。\n```\nconst webpack = require('webpack')\nconst path = require('path')\nconst merge = require('webpack-merge')\nconst baseConfig = require('./webpack.base.conf')\nconst VueSSRClientPlugin = require('vue-server-renderer/client-plugin')\n\nmodule.exports = merge(baseConfig, {\n  plugins: [\n    new VueSSRClientPlugin()\n  ]\n})\n```\n\n客户端的配置就完成了。server 端需要修改输入和输出的配置，还有 source-map 输出的格式，module 中 引入的 css 文件不打包到 module 中，增加 SSR 的 server 端插件。\n```\nconst webpack = require('webpack')\nconst path = require('path')\nconst merge = require('webpack-merge')\nconst baseConfig = require('./webpack.base.conf')\nconst nodeExternals = require('webpack-node-externals')\nconst VueSSRServerPlugin = require('vue-server-renderer/server-plugin')\n\nmodule.exports = merge(baseConfig, {\n  entry: './src/entry-server.js',\n  output: {\n    filename: 'server-bundle.js',\n    libraryTarget: 'commonjs2' // 代码中模块的实现方式，Node.js 使用 commonjs2\n  },\n  target: 'node', // 指定代码的运行环境是 node\n  devtool: '#source-map',\n  externals: nodeExternals({\n    whitelist: /\\.css$/\n  }),\n  plugins: [\n    new VueSSRServerPlugin()\n  ]\n})\n```\n\n然后在 package.json 中添加编译的命令：\n```\n\"scripts\": {\n  \"test\": \"\",\n  \"dev\": \"cross-env NODE_ENV=development webpack-dev-server --open --hot --config build/webpack.client.conf.js\",\n  \"server\": \"node server.js\",\n  \"build\": \"rimraf dist && npm run build:client && npm run build:server\",\n  \"build:client\": \"cross-env NODE_ENV=production webpack --config build/webpack.client.conf.js --progress --hide-modules\",\n  \"build:server\": \"cross-env NODE_ENV=production webpack --config build/webpack.server.conf.js --progress --hide-modules\"\n},\n```\n\n运行 `nom run build` 在dist 目录里就会生成构建后的文件，然后把 index.html 修改为 indext.template.html 这个文件名随便，不改也行。dist 目录中有两个不一样的文件，vue-ssr-client-manifest.json 和 vue-ssr-server-bundle.json。具体的使用方法和实现方式，文档写的很清楚，先去 [Bundle Renderer 指引 · GitBook](https://ssr.vuejs.org/zh/bundle-renderer.html) 看看。\n\n## server.js\n然后在写一个简单 Node Server，我这里使用 Koa，其他的都是一样。server.js 的内容如下：\n```javascript\nconst Koa = require('koa')\nconst Vue = require('vue')\nconst { createBundleRenderer } = require('vue-server-renderer')\nconst path = require('path')\nconst fs = require('fs')\nconst serverBundle = require('./dist/vue-ssr-server-bundle.json')\nconst clientManifest = require('./dist/vue-ssr-client-manifest.json')\nconst app = new Koa()\nconst template = fs.readFileSync(path.resolve(__dirname, './index.template.html'), 'utf-8')\nconst renderer = createBundleRenderer(serverBundle, {\n  basedir: path.resolve(__dirname, './dist'),\n  runInNewContext: false,\n  template,\n  clientManifest\n})\n\nconst renderToString = function (context) {\n  return new Promise((resolve, reject) => {\n    renderer.renderToString(context, (err, html) => {\n      if (err) reject(err)\n      resolve(html)\n    })\n  })\n}\n\napp.use(async ctx => {\n  console.log(ctx.req.url)\n  if (ctx.req.url === '/favicon.ico' || ctx.req.url === '/robots.txt') {\n    ctx.body = ''\n    return \n  }\n  // 简单的静态文件处理\n  if (ctx.req.url.indexOf('/dist/') > -1) {\n    const urlpath = ctx.req.url.split('?')[0].slice(1)\n    const filepath = path.resolve(__dirname, './', urlpath)\n    ctx.body = fs.readFileSync(filepath)\n    return\n  }\n  let html = ''\n  try {\n    html = await renderToString({})\n  } catch(err) {\n    ctx.throw(500, err)\n  }\n  ctx.body = html  \n})\n\napp.listen(3000)\nconsole.log('Server listening on http://localhost:3000.')\n```\n\n运行 `nom run server` 就可以看到服务器渲染出来的页面了。\n![](https://user-gold-cdn.xitu.io/2017/11/6/b47cd1451803665e00fd32bfe8066e48)\n\n## 增加前端方法\n这只是一个简单的静态页面，没有 js 方法动态创建一些内容，我们再添加一些前端方法，看看渲染出来的页面中客户端 js 的运行是不是可以的。\n修改 App.vue 文件：\n```\n<template>\n  <div class=\"demo\" id=\"app\">\n    <h1>Simple-webpack demo</h1>\n    <p>这是一个简单的 Vue demo</p>\n    <img src=\"./assets/logo.png\" alt=\"\">\n    <p>测试一下 SSR</p>\n    <p v-for=\"(text, index) in textArr\" :key=\"index\">{{ text }}</p>\n    <button @click=\"clickHandler\">新增一个行文字</button>\n  </div>\n</template>\n<script>\nexport default {\n  data () {\n    return {\n      textArr: []\n    }\n  },\n  methods: {\n    clickHandler () {\n      this.textArr.push(`${this.textArr.length + 1}. 这是新增的文字。`)\n    }\n  }\n}\n</script>\n```\n\n然后再次构建整个工程，重新启动服务器。\n![](https://user-gold-cdn.xitu.io/2017/11/6/8f056847f964d2bafae16c2df8c3b4e9)\nSuccess！\n\n## 简单的数据注入\n比如渲染一个新闻页面，希望网页的标题是页面直接渲染出来的？应该怎么做？Vue.js SSR 提供了方法，能够插入模板变量。只要在 index.template.html 中加入模板变量就可以像其他的后端模板一样插入数据。首先修改一下 index.template.html 中，增加 `title` 变量，`<title>SSR demo - {{ title }}</title>` 。\n然后在 server.js 中的 `renderToString`方法中的第一个参数传入 `{ title: '第一个 SSR Demo'}`。\n最后再重启一下后台服务，如下图，我们的页面标题变成了我们定义的了。\n![](https://user-gold-cdn.xitu.io/2017/11/6/7cac66b02e16b7589bc202401693503a)\n\n如果还想更复杂的数据我们只能用注入一个 window 全局变量了。这个时候我们还没办法用组件的静态方法，通过后台服务去注入，因为我们没有用到router，不知道app中的组件是不是已经实例化，没办法去获取组件里的静态方法。借鉴 SSR 官方中的 `window.__INIT_STATE` 的方式，先在 index.template.html 中 增加一个 script 标签加入模板变量，然后在 server.js 中传入数据，最后修改 App.vue 文件在 `mounted` 中判断获取这个变量，将变量赋值给组件的 `data` 属性中，具体的代码如下：\n```html\n<!-- index.template.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n  <title>SSR demo - {{ title }}\n  </title>\n  <script>\n    {{{ injectData }}}\n  </script>\n</head>\n<body>\n  <!--vue-ssr-outlet-->\n</body>\n</html>\n```\n\n```javascript\n// server.js\nhtml = await renderToString({\n  title: '第一个 SSR Demo',\n  injectData: 'window.__INIT_DATA__ = ' + JSON.stringify({\n    text: '这是服务器注入的数据。'\n  }) \n})\n```\n\n```html\n<!-- App.vue -->\n<template>\n  <div class=\"demo\" id=\"app\">\n    <h1>Simple-webpack demo</h1>\n    <p>这是一个简单的 Vue demo</p>\n    <img src=\"./assets/logo.png\" alt=\"\">\n    <p>测试一下 SSR</p>\n    <p> {{ serverData.text }}</p>\n    <p v-for=\"(text, index) in textArr\" :key=\"index\">{{ text }}</p>\n    <button @click=\"clickHandler\">新增一个行文字</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  data () {\n    return {\n      textArr: [],\n      serverData: ''\n    }\n  },\n  mounted () {\n    this.serverData = window.__INIT_DATA__\n  },\n  methods: {\n    clickHandler () {\n      this.textArr.push(`${this.textArr.length + 1}. 这是新增的文字。`)\n    }\n  }\n}\n</script>\n```\n\n重新编译，重启服务后，页面上就会多一段文字了，如下图所示：\n![](https://user-gold-cdn.xitu.io/2017/11/6/36eba657b6c3a6f1ef46b40441355aab)\n\nSuccess！\n所有的代码都在这个上面 [wheato/ssr-step-by-step](https://github.com/wheato/ssr-step-by-step/tree/master/simple-ssr-demo)\n## 参考\n[Vue.js 服务器端渲染指南](https://ssr.vuejs.org/zh/)","tags":["Vue"]},{"title":"Vue.js SSR Step by Step (1) - 实现简单的client-only vue-webpack 配置","url":"/2017/10/31/vue-ssr-1/","content":"\n一直都觉得SSR是一个挺麻烦的事情，牵扯的知识范围还挺大的，尤其是用vue-cli 工具，屏蔽了许多配置的细节。\n但在使用SSR，不用Nuxt.js 的时候来做SSR，还是挺难上手的，索性好好捋一遍这方面的相关知识，总结成了一个系列的文章。作为 SSR 文档的一个补充，希望对大家有所帮助。\n\n## 目标\n这篇文章的主要目的解读一个简单的 vue-webpack 如何搭建和每一个插件的作用。完成一个 client-only的 vue-webpack 开发环境，具备以下的功能：\n* 处理 vue 单文件组件\n* 编译 ES6\n* 编译 Less 或者 Sass\n* 加载图片\n* 开发服务器\n* 热加载\n* 定义环境变量\n* 能区分生产环境进行压缩\n\n对这相关配置已经非常了解了的同学可以直接关闭了。\n\n## 添加基本功能\n从这一节开始会贴出一步一步实现的代码，尽量还原整个配置的细节。\n\n### 创建项目文件\n```\n$ mkdir simple-webpack && cd simple-webpack\n$ npm init\n```\n\n然后按照下面的目录结构新建文件。\n```\n.\n├── index.html\n├── package.json\n├── src\n│   ├── App.vue\n│   ├── app.js\n│   └── assets\n└── webpack.config.js\n```\n\n### 安装对应依赖\n需要安装 webpack 需要的依赖有：\n* webpack\n* vue-loader\n* babel-core\n* css-loader\n* babel-loader\n* file-loader\n* sass-loader\n* node-sass\n\n依次安装时，把安装依赖保存到package.json，以便下次在不同的环境下使用时，能快速的安装依赖。\n\n### 添加Vue代码\nindex.html\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n  <title>simple - webpack</title>\n</head>\n<body>\n\t<div id=\"app\"></div>\n  <script src=\"/dist/build.js\"></script>\n</body>\n</html>\n```\n\nApp.vue\n```html\n<template>\n  <div class=\"demo\">\n    <h1>Simple-webpack demo</h1>\n    <p>这是一个简单的 Vue demo</p>\n  </div>\n</template>\n\n<script>\n</script>\n\n<style>\n</style>\n```\n\napp.js\n```\nimport Vue from 'vue'\nimport App from './App.vue'\n\nnew Vue({\n  el: '#app',\n  render: h => h(App)\n})\n```\n\n### 添加 webpack.config 配置\n先写好我们的入口文件和输出文件的地址和打包后的文件名。\n```javascript\nconst webpack = require('webpack')\nconst path = require('path')\n\nmodule.exports = {\n  entry: './src/app.js',\n  output: {\n    path: path.resolve(__dirname, './dist/'),\n    filename: 'build.js'\n  }\n}\n```\n\n添加 vue-loader \n```javascript\nmodule.exports = {\n  entry: './src/app.js',\n  output: {\n    path: path.resolve(__dirname, './dist/'),\n    publicPath: '/dist/',\n    filename: 'build.js'\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.vue$/,\n        loader: 'vue-loader',\n        options: ''\n      }\n    ]\n  }\n}\n```\n此时运行 `webpack` 打包就可以打包成一个可用的程序了，大家可以自行打包后将文件放在静态服务器中运行。\n完成这个基本的打包，用到的webpack loader 和包有：\n* vue-loader [GitHub - vuejs/vue-loader](https://github.com/vuejs/vue-loader)\n* babel-core [babel-core](https://www.npmjs.com/package/babel-core)\n* css-loader [css-loader](https://www.npmjs.com/package/css-loader)\n\n这个包 npm 官网上都有详细的介绍，这里就不赘述了，大家可以自行去看各个loader 在上面的打包过程中完成什么样工作。\n\n为了让我们编写的代码能在低版本的浏览器中使用，我们添加 babel-loader，在打包的时候将文件中的 ES6 语法转成 .bablerc 中配置的版本。\n```javascript\nmodule: {\n    rules: [\n      {\n        test: /\\.vue$/,\n        loader: 'vue-loader',\n        options: ''\n      },\n      {\n        test: /\\.js$/,\n        loader: 'babel-loader',\n        include: [path.resolve(__dirname, './src')]\n      }\n    ]\n  }\n```\n在目录下创建 .babelrc，配置内容如下:\n```json\n{\n  \"presets\": [\n    [\"env\", { \"modules\": false }]\n  ]\n}\n```\n然后需要安装一个 babel 插件，**babel-preset-env**， 关于这个插件的作用具体参见 [`babel-preset-env`: a preset that configures Babel for you](http://2ality.com/2017/02/babel-preset-env.html)\n\n给 App.vue 中添加图片：\n```html\n<template>\n  <div class=\"demo\">\n    <h1>Simple-webpack demo</h1>\n    <p>这是一个简单的 Vue demo</p>\n    <img src=\"./assets/logo.png\" alt=\"\">\n  </div>\n</template>\n```\n\n因为添加了图片，再运行 webpack 打包的时候，webpack 会报错，因为没有对应的 loader 去加载这些二进制文件。\n添加 file-loader：\n```javascript\nmodule: {\n    rules: [\n      {\n        test: /\\.vue$/,\n        loader: 'vue-loader',\n        options: ''\n      },\n      {\n        test: /\\.js$/,\n        loader: 'babel-loader',\n        include: [path.resolve(__dirname, './src')]\n      },\n      {\n        test: /\\.(png|jpg|svg|git)$/,\n        loader: 'file-loader',\n        include: [path.resolve(__dirname, './src/assets')]\n      }\n    ]\n  },\n```\n\n目前我们在单文件组件中，可以使用 css，但是还不能使用 sass，我再添加一个对应的 sass-loader 来处理 sass 文件，因为 css/sass 是 vue-loader 在做代码分割的时候分割出来的文本段，我们只需要在 vue-loader 的 options 中添加对应的配置。\n```javascript\nmodule: {\n  rules: [\n    {\n      test: /\\.vue$/,\n      loader: 'vue-loader',\n      options: {\n        'scss': 'vue-style-loader!css-loader!sass-loader',\n        'sass': 'vue-style-loader!css-loader!sass-loader?indentedSyntax'\n      }\n    },\n    {\n      test: /\\.js$/,\n      loader: 'babel-loader',\n      include: [path.resolve(__dirname, './src')]\n    },\n    {\n      test: /\\.(png|jpg|svg|git)$/,\n      loader: 'file-loader',\n      options: {\n        name: '[name].[ext]?[hash]'\n      }\n    }\n  ]\n},\n```\n\n到目前为止，一个具备打包编译 Vue 项目的 webpack 环境配置已经写好了。接下来我们添加两个比较重要的辅助工具 devServer 和 hot replace。\n\n## 添加Dev Server 和热更新\n添加 Dev Server 的方式的方式有两种：\n* webpack-dev-server\n* webpack-dev-middleware\n\n两种的使用方式和配置可以看这篇官网介绍 [开发](https://doc.webpack-china.org/guides/development)。这里我们选用一种比较简单的方式，直接使用 webpack-dev-server。\n先安装 `npm install -S webpack-dev-server` ，再修改 package.json 添加 npm script，代码如下：\n```\n\"scripts\": {\n  \"test\": \"\",\n  \"dev\": \"webpack-dev-server --open\"\n}\n```\nopen 参数代表服务启动后会自动在浏览器中打开页面。然后再打开 webpack.config.js 文件，添加 devServer 的相关配置。除了以上的配置还能修改 host 和 port，这里我们使用默认就行。添加 hot replace 也是非常简单的，webpack 自带了这一个 plugin，具体使用方法可以看 [模块热替换](https://doc.webpack-china.org/guides/hot-module-replacement)，新增的配置代码如下：\n``` javascript\nmodule: {\n //...\n},\ndevServer: {\n  historyApiFallback: true,\n  hot: true,\n  noInfo: false,\n  overlay: true\n},\nplugins: [\n  new webpack.HotModuleReplacementPlugin()\n]\n```\n\n## 添加环境变量\n`process` 是 node 中的一个模块，我们可以用它的 env 变量来区分 shell 的环境变量。这样我们就可以通过 `npm run dev` 和 `npm run build`来区分我们是开发还是生产构建。\n先修改两个 npm script 来区分 shell 环境变量，这里我们借助 **[cross-env](https://www.npmjs.com/package/cross-env)**  npm 模块实现自定义的环境变量。\n```json\n\"scripts\": {\n  \"test\": \"\",\n  \"dev\": \"cross-env NODE_ENV=development webpack-dev-server --open --hot\",\n  \"build\": \"cross-env NODE_ENV=production webpack\"\n}\n```\n\n```javascript\n// webpack.config.js\nmodule.exports = {\n\t//...\n}\nconsole.log(process.env.NODE_ENV)\nif (process.env.NODE_ENV === 'production') {\n  module.exports.devtool = '#source-map'\n  module.exports.plugins = (module.exports.plugins || []).concat([\n    new webpack.DefinePlugin({\n      'process.env': {\n        NODE_ENV: '\"production\"'\n      }\n    }),\n    new webpack.optimize.UglifyJsPlugin({\n      sourceMap: true,\n      compress: {\n        warnings: false\n      }\n    }),\n    new webpack.LoaderOptionsPlugin({\n      minimize: true\n    })\n  ])\n}\n```\n在 production 环境中添加了两个插件，优化打包的代码和压缩 JS 代码。第一个插件 **DefinePlugin** 是为前端代码提供与 webpack 一致的环境变量，便于我们在业务代码中区分不同的环境，Vue 框架中也要根据这个环境变量来切分开发环境和生产环境。\n我们再稍微整理一下配置，一个简单 client-only 的 webpack 的配置就写好了。\n```\nconst webpack = require('webpack')\nconst path = require('path')\n\nmodule.exports = {\n  entry: './src/app.js',\n  output: {\n    path: path.resolve(__dirname, './dist/'),\n    publicPath: '/dist/',\n    filename: 'build.js'\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.vue$/,\n        loader: 'vue-loader',\n        options: {\n          'scss': 'vue-style-loader!css-loader!sass-loader',\n          'sass': 'vue-style-loader!css-loader!sass-loader'\n        }\n      },\n      {\n        test: /\\.js$/,\n        loader: 'babel-loader',\n        include: [path.resolve(__dirname, './src')]\n      },\n      {\n        test: /\\.(png|jpg|svg|git)$/,\n        loader: 'file-loader',\n        options: {\n          name: '[name].[ext]?[hash]'\n        }\n      }\n    ]\n  }\n}\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports.devtool = '#source-map'\n  module.exports.plugins = (module.exports.plugins || []).concat([\n    new webpack.DefinePlugin({\n      'process.env': {\n        NODE_ENV: '\"production\"'\n      }\n    }),\n    new webpack.optimize.UglifyJsPlugin({\n      sourceMap: true,\n      compress: {\n        warnings: false\n      }\n    }),\n    new webpack.LoaderOptionsPlugin({\n      minimize: true\n    })\n  ])\n} else {\n  module.exports.devtool = '#eval-source-map'\n  module.exports.devServer = {\n    historyApiFallback: true,\n    hot: true,\n    noInfo: false,\n    overlay: true\n  }\n  module.exports.plugins = (module.exports.plugins || []).concat([\n    new webpack.HotModuleReplacementPlugin()    \n  ])\n}\n```\n本文只是梳理打造一个简单配置的过程，为后面的 SSR 配置作为基础。webpack 的配置项非常多，而 vue-cli 中提供的 webpack 配置远没有那么简单。更进阶的方式可以阅读**参考**中文章。\n\n## 参考\n* [process对象 — JavaScript 标准参考教程（alpha）](http://javascript.ruanyifeng.com/nodejs/process.html)\n* [webpack 中文文档](https://doc.webpack-china.org/)\n* [vue-cli webpack配置分析 - chenBright - SegmentFault](https://segmentfault.com/a/1190000008644830)\n* [webpack-simple/template at master · vuejs-templates/webpack-simple · GitHub](https://github.com/vuejs-templates/webpack-simple/tree/master/template)","tags":["Vue"]},{"title":"2018年终总结Promise 异步流程控制","url":"/2017/09/29/promise-async/","content":"\n## 前言\n最近部门在招前端，作为部门唯一的前端，面试了不少应聘的同学，面试中有一个涉及 Promise 的一个问题是：\n> 网页中预加载20张图片资源，分步加载，一次加载10张，两次完成，怎么控制图片请求的并发，怎样感知当前异步请求是否已完成？  \n\n然而能全部答上的很少，能够给出一个回调 + 计数版本的，我都觉得合格了。那么接下来就一起来学习总结一下基于 Promise 来处理异步的三种方法。\n\n本文的例子是一个极度简化的一个漫画阅读器，用4张漫画图的加载来介绍异步处理不同方式的实现和差异，以下是 HTML 代码：\n```HTML\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n  <title>Promise</title>\n  <style>\n    .pics{\n      width: 300px;\n      margin: 0 auto;\n    }\n    .pics img{\n      display: block;\n      width: 100%;\n    }\n    .loading{\n      text-align: center;\n      font-size: 14px;\n      color: #111;\n    }\n  </style>\n</head>\n<body>\n  <div class=\"wrap\">\n    <div class=\"loading\">正在加载...</div>\n    <div class=\"pics\">\n    </div>\n  </div>\n  <script>\n  </script>\n</body>\n</html>\n```\n\n## 单一请求\n最简单的，就是将异步一个个来处理，转为一个类似同步的方式来处理。\n先来简单的实现一个单个 Image 来加载的 thenable 函数和一个处理函数返回结果的函数。\n```javascript\nfunction loadImg (url) {\n  return new Promise((resolve, reject) => {\n    const img = new Image()\n    img.onload = function () {\n      resolve(img)\n    }\n    img.onerror = reject\n    img.src = url\n  })\n}\n``` \n\n异步转同步的解决思想是：当第一个 `loadImg(urls[1])`  完成后再调用 `loadImg(urls[2])`，依次往下。如果 `loadImg()` 是一个同步函数，那么很自然的想到用__循环__。\n```javascript\nfor (let i = 0; i < urls.length; i++) {\n\tloadImg(urls[i])\n}\n``` \n当 `loadImg()` 为异步时，我们就只能用 Promise chain 来实现，最终形成这种方式的调用：\n```javascript\nloadImg(urls[0])\n\t.then(addToHtml)\n\t.then(()=>loadImg(urls[1]))\n\t.then(addToHtml)\n\t//...\n  .then(()=>loadImg(urls[3]))\n  .then(addToHtml)\n```\n\n那我们用一个中间变量来存储当前的 promise ，就像链表的游标一样，改过后的 `for` 循环代码如下：\n```javascript\nlet promise = Promise.resolve()\nfor (let i = 0; i < urls.length; i++) {\n\tpromise = promise\n\t\t\t\t.then(()=>loadImg(urls[i]))\n\t\t\t\t.then(addToHtml)\n}\n```\n\npromise 变量就像是一个迭代器，不断指向最新的返回的 Promise，那我们就进一步使用 reduce 来简化代码。\n```javascript\nurls.reduce((promise, url) => {\n\treturn promise\n\t\t\t\t.then(()=>loadImg(url))\n\t\t\t\t.then(addToHtml)\n}, Promise.resolve())\n```\n\n在程序设计中，是可以通过函数的__递归__来实现循环语句的。所以我们将上面的代码改成__递归__:\n```javascript\nfunction syncLoad (index) {\n  if (index >= urls.length) return \n\tloadImg(urls[index])\n\t  .then(img => {\n\t\t// process img\n      addToHtml(img)\n      syncLoad (index + 1)\n    })\n}\n\n// 调用\nsyncLoad(0)\n```\n\n好了一个简单的异步转同步的实现方式就已经完成，我们来测试一下。\n这个实现的简单版本已经实现没问题，但是最上面的正在加载还在，那我们怎么在函数外部知道这个递归的结束，并隐藏掉这个 DOM 呢？`Promise.then()` 同样返回的是 thenable 函数 我们只需要在 `syncLoad` 内部传递这条 Promise 链，直到最后的函数返回。\n```javascript\nfunction syncLoad (index) {\n  if (index >= urls.length) return Promise.resolve()\n  return loadImg(urls[index])\n    .then(img => {\n      addToHtml(img)\n      return syncLoad (index + 1)\n    })\n}\n\n// 调用\nsyncLoad(0)\n  .then(() => {\n\t  document.querySelector('.loading').style.display = 'none'\n\t})\n```\n现在我们再来完善一下这个函数，让它更加通用，它接受__异步函数__、__异步函数需要的参数数组__、__异步函数的回调函数__三个参数。并且会记录调用失败的参数，在最后返回到函数外部。另外大家可以思考一下为什么 catch 要在最后的 then 之前。\n```javascript\nfunction syncLoad (fn, arr, handler) {\n  if (typeof fn !== 'function') throw TypeError('第一个参数必须是function')\n  if (!Array.isArray(arr)) throw TypeError('第二个参数必须是数组')\n  handler = typeof fn === 'function' ? handler : function () {}\n  const errors = []\n  return load(0)\n  function load (index) {\n    if (index >= arr.length) {\n      return errors.length > 0 ? Promise.reject(errors) : Promise.resolve()\n    }\n    return fn(arr[index])\n      .then(data => {\n        handler(data)\n      })\n      .catch(err => {\n        console.log(err)              \n        errors.push(arr[index])\n        return load(index + 1)\n      })\n      .then(() => {\n        return load (index + 1)\n      })\n  }\n}\n\n// 调用\nsyncLoad(loadImg, urls, addToHtml)\n  .then(() => {\n    document.querySelector('.loading').style.display = 'none'\n  })\n  .catch(console.log)\n```\ndemo1地址：[单一请求 - 多个 Promise 同步化](https://wheato.github.io/demo/promise-demo/demo1.html)\n\n至此，这个函数还是有挺多不通用的问题，比如：处理函数必须一致，不能是多种不同的异步函数组成的队列，异步的回调函数也只能是一种等。关于这种方式的更详细的描述可以看我之前写的一篇文章 [Koa引用库之Koa-compose - 掘金](https://juejin.im/post/6844903496257585160)。\n\n当然这种异步转同步的方式在这一个例子中并不是最好的解法，但当有合适的业务场景的时候，这是很常见的解决方案。\n\n## 并发请求\n毕竟同一域名下能够并发多个 HTTP 请求，对于这种不需要按顺序加载，只需要按顺序来处理的并发请求，`Promise.all` 是最好的解决办法。因为`Promise.all` 是原生函数，我们就引用文档来解释一下。\n> Promise.all(iterable) 方法指当所有在可迭代参数中的 promises 已完成，或者第一个传递的 promise（指 reject）失败时，返回 promise。  \n> 出自 [Promise.all() - JavaScript | MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/all)  \n\n那我们就把demo1中的例子改一下：\n```javascript\nconst promises = urls.map(loadImg)\nPromise.all(promises)\n  .then(imgs => {\n    imgs.forEach(addToHtml)\n    document.querySelector('.loading').style.display = 'none'\n  })\n  .catch(err => {\n    console.error(err, 'Promise.all 当其中一个出现错误，就会reject。')\n  })\n```\ndemo2地址：[并发请求 - Promise.all](https://wheato.github.io/demo/promise-demo/demo2.html)\n\n## 并发请求，按顺序处理结果\n`Promise.all` 虽然能并发多个请求，但是一旦其中某一个 promise 出错，整个 promise 会被 `reject` 。\nwebapp 里常用的资源预加载，可能加载的是 20 张逐帧图片，当网络出现问题， 20 张图难免会有一两张请求失败，如果失败后，直接抛弃其他被 `resolve` 的返回结果，似乎有点不妥，我们只要知道哪些图片出错了，把出错的图片再做一次请求或着用占位图补上就好。\n上节中的代码 `const promises = urls.map(loadImg)` 运行后，全部都图片请求都已经发出去了，我们只要按顺序挨个处理 `promises`  这个数组中的 Promise 实例就好了，先用一个简单点的 `for` 循环来实现以下，跟第二节中的单一请求一样，利用 Promise 链来顺序处理。\n```javascript\nlet task = Promise.resolve()\nfor (let i = 0; i < promises.length; i++) {\n  task = task.then(() => promises[i]).then(addToHtml)\n}\n```\n改成 reduce 版本\n```javascript\npromises.reduce((task, imgPromise) => {\n  return task.then(() => imgPromise).then(addToHtml)\n}, Promise.resolve())\n```\ndemo3地址：[Promise 并发请求，顺序处理结果](https://wheato.github.io/demo/promise-demo/demo3.html)\n\n## 控制最大并发数\n现在我们来试着完成一下上面的笔试题，这个其实都__不需要控制最大并发数__。\n20张图，分两次加载，那用两个 `Promise.all` 不就解决了？但是用 `Promise.all` 没办法侦听到每一张图片加载完成的事件。而用上一节的方法，我们既能并发请求，又能按顺序响应图片加载完成的事件。\n```javascript\nlet index = 0\nconst step1 = [], step2 = []\n\nwhile(index < 10) {\n  step1.push(loadImg(`./images/pic/${index}.jpg`))\n  index += 1\n}\n\nstep1.reduce((task, imgPromise, i) => {\n  return task\n    .then(() => imgPromise)\n    .then(() => {\n      console.log(`第 ${i + 1} 张图片加载完成.`)\n    })\n}, Promise.resolve())\n  .then(() => {\n    console.log('>> 前面10张已经加载完！')\n  })\n  .then(() => {\n    while(index < 20) {\n      step2.push(loadImg(`./images/pic/${index}.jpg`))\n      index += 1\n    }\n    return step2.reduce((task, imgPromise, i) => {\n      return task\n        .then(() => imgPromise)\n        .then(() => {\n          console.log(`第 ${i + 11} 张图片加载完成.`)\n        })\n    }, Promise.resolve())\n  })\n  .then(() => {\n    console.log('>> 后面10张已经加载完')\n  })\n```\n上面的代码是针对题目的 hardcode ，如果笔试的时候能写出这个，都已经是非常不错了，然而并没有一个人写出来，said...\ndemo4地址(看控制台和网络请求)：[Promise 分步加载 - 1](https://wheato.github.io/demo/promise-demo/demo4.html)\n\n那么我们在抽象一下代码，写一个通用的方法出来，这个函数返回一个 Promise，还可以继续处理全部都图片加载完后的异步回调。\n```javascript\nfunction stepLoad (urls, handler, stepNum) {\n\tconst createPromises = function (now, stepNum) {\n    let last = Math.min(stepNum + now, urls.length)\n    return urls.slice(now, last).map(handler)\n  }\n  let step = Promise.resolve()\n  for (let i = 0; i < urls.length; i += stepNum) {\n    step = step\n      .then(() => {\n        let promises = createPromises(i, stepNum)\n        return promises.reduce((task, imgPromise, index) => {\n          return task\n            .then(() => imgPromise)\n            .then(() => {\n              console.log(`第 ${index + 1 + i} 张图片加载完成.`)\n            })\n        }, Promise.resolve())\n      })\n      .then(() => {\n        let current = Math.min(i + stepNum, urls.length)\n        console.log(`>> 总共${current}张已经加载完！`)\n      })\n  }\n\treturn step\n}\n```\n上面代码里的 `for` 也可以改成 `reduce` ，不过需要先将需要加载的 `urls` 按分步的数目，划分成数组，感兴趣的朋友可以自己写写看。\ndemo5地址(看控制台和网络请求)：[Promise 分步 - 2](https://wheato.github.io/demo/promise-demo/demo5.html)\n\n但上面的实现和我们说的__最大并发数控制__没什么关系啊，最大并发数控制是指：当加载 20 张图片加载的时候，先并发请求 10 张图片，当一张图片加载完成后，又会继续发起一张图片的请求，让并发数保持在 10 个，直到需要加载的图片都全部发起请求。这个在写爬虫中可以说是比较常见的使用场景了。\n那么我们根据上面的一些知识，我们用两种方式来实现这个功能。\n\n### 使用递归\n假设我们的最大并发数是 4 ，这种方法的主要思想是相当于 4 个__单一请求__的 Promise 异步任务在同时运行运行，4 个单一请求不断递归取图片 URL 数组中的 URL 发起请求，直到 URL 全部取完，最后再使用 `Promise.all` 来处理最后还在请求中的异步任务，我们复用第二节__递归__版本的思路来实现这个功能：\n```javascript\nfunction limitLoad (urls, handler, limit) {\n  const sequence = [].concat(urls) // 对数组做一个拷贝\n  let count = 0\n  const promises = []\n\n  const load = function () {\n    if (sequence.length <= 0 || count > limit) return \n    count += 1\n    console.log(`当前并发数: ${count}`)\n    return handler(sequence.shift())\n      .catch(err => {\n        console.error(err)\n      })\n      .then(() => {\n        count -= 1\n        console.log(`当前并发数：${count}`)\n      })\n      .then(() => load())\n  }\n\n  for(let i = 0; i < limit && i < urls.length; i++){\n    promises.push(load())\n  }\n  return Promise.all(promises)\n}\n```\n设定最大请求数为 5，Chrome 中请求加载的 timeline ：\n![](https://user-gold-cdn.xitu.io/2017/9/29/bf5d754752488138bd8266ad1b6ec795)\ndemo6地址(看控制台和网络请求)：[Promise 控制最大并发数 - 方法1](https://wheato.github.io/demo/promise-demo/demo6.html)\n\n### 使用 `Promise.race`\n`Promise.race` 接受一个 Promise 数组，返回这个数组中最先被  `resolve` 的 Promise 的返回值。终于找到 `Promise.race` 的使用场景了，先来使用这个方法实现的功能代码：\n```javascript\nfunction limitLoad (urls, handler, limit) {\n  const sequence = [].concat(urls) // 对数组做一个拷贝\n  let count = 0\n  let promises\n  const wrapHandler = function (url) {\n    const promise = handler(url).then(img => {\n      return { img, index: promise }\n    })\n    return promise\n  }\n  //并发请求到最大数\n  promises = sequence.splice(0, limit).map(url => {\n    return wrapHandler(url)\n  })\n  // limit 大于全部图片数, 并发全部请求\n  if (sequence.length <= 0) { \n    return Promise.all(promises)\n  }\n  return sequence.reduce((last, url) => {\n    return last.then(() => {\n      return Promise.race(promises)\n    }).catch(err => {\n      console.error(err)\n    }).then((res) => {\n      let pos = promises.findIndex(item => {\n        return item == res.index\n      })\n      promises.splice(pos, 1)\n      promises.push(wrapHandler(url))\n    })\n  }, Promise.resolve()).then(() => {\n    return Promise.all(promises)\n  })\n}\n```\n设定最大请求数为 5，Chrome 中请求加载的 timeline ：\n![](https://user-gold-cdn.xitu.io/2017/9/29/45c5bdfade4f5078f2c3a9b40aebcf1e)\ndemo7地址(看控制台和网络请求)：[Promise 控制最大并发数 - 方法2](https://wheato.github.io/demo/promise-demo/demo7.html)\n\n在使用  `Promise.race` 实现这个功能，主要是不断的调用 `Promise.race` 来返回已经被 `resolve`  的任务，然后从 `promises` 中删掉这个 Promise 对象，再加入一个新的 Promise，直到全部的 URL 被取完，最后再使用 `Promise.all` 来处理所有图片完成后的回调。\n\n## 写在最后\n因为工作里面大量使用 ES6 的语法，Koa 中的 await/async 又是 Promise 的语法糖，所以了解 Promise 各种流程控制是对我来说是非常重要的。写的有不明白的地方和有错误的地方欢迎大家留言指正，另外还有其他没有涉及到的方法也请大家提供一下新的方式和方法。\n\n## 题外话\n我们目前有 1 个前端的 HC，base 深圳，一家拥有 50 架飞机的物流公司的AI部门，要求工作经验三年以上，这是公司社招要求的。\n感兴趣的就联系我吧，Email: d2hlYXRvQGZveG1haWwuY29t\n\n## 参考资料\n* [JavaScript Promise：简介  |  Web       |  Google Developers](https://developers.google.com/web/fundamentals/primers/promises?hl=zh-cn)\n* [JavaScript Promise迷你书（中文版）](http://liubin.org/promises-book/#chapter4-advanced-promise)","tags":["JavaScript"]},{"title":"2018年终总结Promise 异步流程控制","url":"/2017/09/19/compose/","content":"\n## 概述\n` compose ` 是一个工具函数，` Koa.js ` 的中间件通过这个工具函数组合后，按 ` app.use() ` 的顺序同步执行，也就是形成了 洋葱圈 式的调用。\n\n这个函数的源代码不长，不到50行，代码地址 [https://github.com/koajs/compose](https://github.com/koajs/compose)\n\n利用递归实现了 Promise 的链式执行，不管中间件中是同步还是异步都通过  Promise 转成异步链式执行。\n\n## 源码解读\n\n```javascript\nfunction compose (middleware) {\n  if (!Array.isArray(middleware)) throw new TypeError('Middleware stack must be an array!')\n  for (const fn of middleware) {\n    if (typeof fn !== 'function') throw new TypeError('Middleware must be composed of functions!')\n  }\n  ...\n} \n```\n\n函数开头对参数做了类型的判断，确保输入的正确性。__middleware__ 必须是一个数组，数组中的元素必须是 `function` 。\n\n``` javascript\nfunction compose (middleware) {\n  //...\n \n  return function (context, next) {\n    // last called middleware #\n    let index = -1\n    return dispatch(0)\n    function dispatch (i) {\n      if (i <= index) return Promise.reject(new Error('next() called multiple times'))\n      index = i\n      let fn = middleware[i]\n      if (i === middleware.length) fn = next\n      if (!fn) return Promise.resolve()\n      try {\n        return Promise.resolve(fn(context, function next () {\n          return dispatch(i + 1)\n        }))\n      } catch (err) {\n        return Promise.reject(err)\n      }\n    }\n  }\n}\n```\n\n接下来，是返回了一个函数，接受两个参数，`context` 和 `next`。`context` 是 __koa__ 中的 `ctx`，`next` 是所有中间件执行完后，框架使用者来最后处理请求和返回的回调函数。同时函数是一个闭包函数，存储了所有的中间件，通过递归的方式不断的运行中间件。\n\n通过代码可以看到，作为中间件同样必须接受两个参数， `context` 和 `next`。如果某个中间件没有调用 `next()` , 后面的中间件是不会执行的。这是非常常见的将多个异步函数转为同步的处理方式。\n\n## Middleware函数的写法\n直接看代码：\n``` javascript\nconst compose = require('./compose')\n\nfunction mw1 (context, next) {\n  console.log('===== middleware 1 =====')\n  console.log(context)\n  setTimeout(() => {\n    console.log(`inner: ${context}`)\n    next()\n  }, 1000)\n}\n\nfunction mw2 (context, next) {\n  console.log('===== middleware 2 =====')\n  console.log(context)\n  next()\n}\n\nfunction mw3 (context, next) {\n  console.log('===== middleware 3 =====')\n  console.log(context)\n  setTimeout(() => {\n    console.log(`inner: ${context}`)\n  }, 1000)\n  next()\n}\n\nconst run = compose([mw1, mw2, mw3])\n\nrun('context', function () {\n  console.log('all middleware done!')\n})\n\n```\n\n输出结果是：\n``` powershell\n===== middleware 1 =====\ncontext\ninner: context\n===== middleware 2 =====\ncontext\n===== middleware 3 =====\ncontext\nall middleware done!\ninner: context\n```\n\n第三个中间件中，故意把 `next()` 写在了异步的外面，会导致中间件还完成就直接进入下一个中间件的运行了（这里是所有中间件运行完后的回调函数）。`compose()` 生成的函数是 __thenable__ 函数，我们改一下最后的运行部分。\n``` javascript\nrun('context').then(() => {\n  console.log('all middleware done!')\n})\n```\n\n结果是：\n```powershell\n===== middleware 1 =====\ncontext\nall middleware done!\ninner: context\n===== middleware 2 =====\ncontext\n===== middleware 3 =====\ncontext\ninner: context\n```\n\n看起来结果不符合我们的预期，这是因为在 __compose__ 源代码中，中间件执行完后返回的是一个 `Promise` 对象，如果我们在 `Promise` 中再使用异步函数并且不使用`then` 来处理异步流程，显然是不合理的，我们可以改一下上面的中间件代码。\n\n```javascript\nfunction mw1 (context, next) {\n  console.log('===== middleware 1 =====')\n  console.log(context)\n  return new Promise(resolve => {\n    setTimeout(() => {\n      console.log(`inner: ${context}`)\n      resolve()\n    }, 1000)\n  }).then(() => {\n    return next ()\n  })\n}\n\nfunction mw2 (context, next) {\n  console.log('===== middleware 2 =====')\n  console.log(context)\n  return next()\n}\n\nfunction mw3 (context, next) {\n  console.log('===== middleware 3 =====')\n  console.log(context)\n  return new Promise(resolve => {\n    setTimeout(() => {\n      console.log(`inner: ${context}`)\n      resolve()\n    }, 1000)\n  }).then(() => {\n    return next ()\n  })\n}\n```\n\n输出：\n```powershell\n===== middleware 1 =====\ncontext\ninner: context\n===== middleware 2 =====\ncontext\n===== middleware 3 =====\ncontext\ninner: context\nall middleware done!\n```\n\n这下没问题了，每一个中间件都会返回一个 __thenable__ 的 `Promise` 对象。\n\n既然是在研究Koa.js 那么我们就把上面的代码再改改，使用 `async/await` 改写一下，把异步函数改成一个 __thenable__ 函数。\n\n```javascript\nasync function sleep (context) {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      console.log(`inner: ${context}`)\n      resolve()\n    }, 1000)\n  })\n}\n\nasync function mw1 (context, next) {\n  console.log('===== middleware 1 =====')\n  console.log(context)\n  await sleep(context)\n  await next()  \n}\n\nasync function mw2 (context, next) {\n  console.log('===== middleware 2 =====')\n  console.log(context)\n  return next()\n}\n\nasync function mw3 (context, next) {\n  console.log('===== middleware 3 =====')\n  console.log(context)\n  await sleep(context)\n  await next ()\n}\n```\n\n## 应用场景\n在日常的开发中，Node 后台一般是作为微服务架构中的一个面向终端的 API Gateway。\n现在有这样一个场景：__我们从三个其他微服务中获取数据再聚合成一个 HTTP API__，如果三个服务提供的 service 没有依赖的话，这种情况比较简单，用 `Promise.all()` 就可以实现，代码如下：\n```javascript\nfunction service1 () {\n  return new Promise((resolve, reject) => {\n    resolve(1)\n  })\n}\n\nfunction service2 () {\n  return new Promise((resolve, reject) => {\n    resolve(2)\n  })\n}\n\nfunction service3 () {\n  return new Promise((resolve, reject) => {\n    resolve(3)\n  })\n}\n\nPromise.all([service1(), service2(), service3()])\n  .then(res => {\n    console.log(res)\n  })\n```\n\n那如果 service2 的请求参数依赖 service1 返回的结果， service3 的请求参数又依赖于 Service2 返回的结果，那就得将一系列的异步请求转成同步请求，__compose__ 就可以发挥其作用了，当然用 __Promise__ 的链式调用也是可以实现的，但是代码耦合度高，不利于后期维护和代码修改，如果 1、2、3 的顺序调换一下，代码改动就比较大了，另外耦合度太高的代码不利于单元测试，这里有一个[文章](https://blog.risingstack.com/dependency-injection-in-node-js/)是通过依赖注入的方式解耦模块，保持模块的独立性，便于模块的单元测试。\n\n## 总结\n__Compose__ 是一种基于 Promise 的流程控制方式，可以通过这种方式对异步流程同步化，解决之前的嵌套回调和 __Promise__ 链式耦合。\n\n__Promise__ 的流程控制有很多种，下篇文章再来写不同应用场景中分别运用的方法。","tags":["JavaScript"]}]